## 04. 삽입 정렬

- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방법
- 시간 복잡도 : O(n2)

### 삽입 정렬 과정

1. 현재 index에 있는 데이터 값을 선택한다.
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다.

**적절한 삽입 위치를 탐색하는 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하여 시간 복잡도를 줄일 수 있다. (O(logN))**

### 예시 (오름차 순)

<img src="https://velog.velcdn.com/images/from-minju/post/62ee5f4b-65f4-4750-8df8-8a85c553f2dc/image.png" width="500px">
[출처] https://velog.io/@from-minju/c-알고리즘-단순-삽입-정렬

#### Step 1
- 두번째 위치한 값을 이미 정렬된 데이터 (첫번째 위치한 값)과 비교한다.
- 적절한 위치 삽입을 위해 삽입 위치 이후의 값 (첫번째 값)을 뒤로 미루고 두번째 값을 그 자리에 삽입한다.

#### Step 2
- 세번째 위치한 값을 이미 정렬된 데이터 (첫번째, 두번째 위치한 값)과 비교한다.
- 적절한 위치 삽입을 위해 삽입 위치 이후의 값 (첫번째, 두번째 값)을 뒤로 미루고 세번째 값을 그 자리에 삽입한다.

#### Step 3, 4
- 위의 과정과 마찬가지로 정렬된 데이터와 비교하며 값을 정렬시켜 나간다.

#### Step 5
- 정렬된 범위가 정렬하고자 하는 데이터 크기와 같아지면 정렬이 완료된다.

```
public void insertionSort(int[] arr) {
    for(int i=1; i<arr.length; i++ {
        int temp = arr[i]; // 선택 데이터
        int aux = i -1; // 정렬된 데이터 위치
        while ( (aux>=0) && arr[aux]>temp) ) {
            // 삽입 위치부터 index에 있는 위치까지 shift 연산 수행
            arr[aux+1] = arr[aux];
            aux--;
        }
        arr[aux+1] = temp; // 삽입 위치에 선택 데이터 삽입
    }
}
```